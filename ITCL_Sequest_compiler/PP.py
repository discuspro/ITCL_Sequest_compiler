
def main():
	#Code generated by Dustin D. Holden, Brodbelt Group, 2015
	
	#protein sequence
	prot_seq = 'ATKAVCVLKGDGPVQGTIHFEAKGDTVVVTGSITGLTEGDHGFHVHQFGDNTQGCTSAGPHFNPLSKKHGGPKDEERHVGDLGNVTADKNGVAIVDIVDPLISLSGEYSIIGRTMVVHEKPDDLGRGGNEESTKTGNAGSRLACGVIGIAK'
	
	#read found peak list from Prosight 
	in_file = open ('fromProtPros.txt', 'r')
	
	#read out header
	in_file.readline()
	
	found_list = []
	for line in in_file:
		line = line.strip()
		line = line.split()
		
		#trim lines that are multiple matches or not matched
		if (len(line) <= 3):
			continue
		else:
			found_list.append(line)
	
	in_file.close()
	
	
	mtype_ions =[]
	v_d_w_ions = []
	neutral_ions = []
	informative_ions = []
	for i in range (len(found_list)):
		#remove neutrals, m-type ions, and v,d, and w-type ions from found_list
		if (found_list[i][3].startswith('m')):
			mtype_ions.append(found_list[i])
		elif ( ((found_list[i][3].count('N')) >= 1) or ((found_list[i][3].count('H')) >= 1) ):	
			neutral_ions.append(found_list[i])	
		elif ( (found_list[i][3].startswith('d')) or (found_list[i][3].startswith('v')) or (found_list[i][3].startswith('w')) ):	
			v_d_w_ions.append(found_list[i])
		#populate list of informative ions
		else:
			informative_ions.append(found_list[i])
	
	#remove duplicate m/z values while being sensitive to keep most intense match between duplicates **Note: will not remove triplicates yet**
	max_intensity = 0
	ppm_err = 0
	for j in range (len(informative_ions) - 2):
		
		if (informative_ions[j] == 'removed'):
			continue
		
		else:
			max_intensity = int(informative_ions[j][2])
			ppm_err = abs(float(informative_ions[j][4]))
			
			#duplicate attention
			if ( informative_ions[j][0] == informative_ions[j+1][0] ):
							
				if ( int(informative_ions[j+1][2]) < max_intensity ):
					informative_ions[j+1] = 'removed'
					
					#triplicate attention
					if ( informative_ions[j][0] == informative_ions[j+2][0] ):
							
						if ( int(informative_ions[j+2][2]) < max_intensity ):
							informative_ions[j+2] = 'removed'
						else:
							if ( abs(float(informative_ions[j+2][4])) > ppm_err ):
								informative_ions[j+2] = 'removed'
							else:
								informative_ions[j] = 'removed'
								
				else:
					if ( abs(float(informative_ions[j+1][4])) > ppm_err ):
						informative_ions[j+1] = 'removed'
					else:
						informative_ions[j] = 'removed'
	
	#duplicate attention for last two positions in informative_ions list
	if ( informative_ions[-2][0] == informative_ions[-1][0] ):
						
		if ( int(informative_ions[-1][2]) <= int(informative_ions[-2][2]) ):
			informative_ions[-1] = 'removed'
										
		else:
			informative_ions[-2] = 'removed'
				
	
	#make new list without 'removed'
	clean_informative_ions = []
	for el in informative_ions:
		if (el != 'removed'):
			clean_informative_ions.append(el)
	
	
	#sum intensities for future calculation of rel. int.
	int_sum = 538000
	#for el in clean_informative_ions:
	#	int_sum += float (el[2])
	
	
	#make new list containing: m/z, Int., Rel. Int., Ion Type, Location, From N, Error
	final_informative_ions = []
	temp_list = []
	for el in clean_informative_ions:
		temp_list = el[3].split(',')
		
		if ( (temp_list[0][0] > 'c') or (temp_list[0][0] == 'Y') ):
			temp_list[2] = ( int(len(prot_seq)) - int(temp_list[1]) )
		else:
			temp_list[2] = int(temp_list[1])
				
		new_line = el[0] + ',' + el[2] + ',' + str(round( ((float(el[2])/int_sum)*100), 6)) + ',' + temp_list[0] + ',' + str(temp_list[1]) + ',' + str(temp_list[2]) + ',' + el[4]
		new_line = new_line.split(',')
		
		final_informative_ions.append( new_line )
	

	#generate a list containing sequence and position numbers, and two extra slots for populating with N and C terminal frag. rel. intensities
	seq_list = []
	temp_list2 = []
	counter = 1
	for i in range (len(prot_seq)):
		temp_list2 = prot_seq[i] + ',' + str(counter) + ',' + '0' + ',' + '0'
		temp_list2 = temp_list2.split(',')
		seq_list.append(temp_list2)
		
		counter += 1
	
	#convert last two values in seq_list to floating type
	for el in seq_list:
		el[2] = float(el[2])
		el[3] = float(el[3])
	
	#populate the seq_list with appropriate rel. intensities from 'final_informative_ions' list
	counter2 = 0
	for k in range ( len(seq_list) ):
		
		for l in range (len(final_informative_ions)):
			if (final_informative_ions[l][5] == seq_list[k][1]):
				if ( (final_informative_ions[l][3].startswith('a')) or (final_informative_ions[l][3].startswith('b')) or (final_informative_ions[l][3].startswith('c')) ):
					seq_list[k][2] += round( (float(final_informative_ions[l][2])), 6)	
				else:
					seq_list[k][3] += round( (float(final_informative_ions[l][2])), 6)
		#count for seq. cov.
		if ( (float(seq_list[k][2]) > 0) or ( float(seq_list[k][3]) > 0) ):
			counter2 += 1
	
	
	#calculate seq. cov.
	seq_cov = ( (counter2/( len(prot_seq)-1 ) ) * 100 )			
	
	#output found peak data header
	out_file = open ('output.txt', 'w')
	out_file.write ('m/z	')
	out_file.write ('Intensity	')
	out_file.write ('Rel. Intensity	')
	out_file.write ('Ion Type	')
	out_file.write ('Location	')
	out_file.write ('From N	')
	out_file.write ('ppm Error	')
	out_file.write ('Seq. Cov. =	')
	out_file.write (str(round(seq_cov)) )
	out_file.write ('%	')
	out_file.write ('TIC =	')
	out_file.write (str(int_sum) )
	out_file.write ('\n')	
	
	#output found peak data	
	for el in final_informative_ions:
		for i in range ( len(el) ):
			out_file.write (el[i])
			out_file.write ('	')
		out_file.write ('\n')
	
	#output sequence data header
	out_file.write ('\n')			
	out_file.write ('Amino Acid	')
	out_file.write ('AA From N	')
	out_file.write ('Nterm Rel. Int.	')
	out_file.write ('Cterm Rel. Int.	\n')
	
	#output sequence data
	for el in seq_list:
		
		out_file.write (el[0])
		#out_file.write ('\n')
		out_file.write ('	')
		out_file.write (el[1])
		out_file.write ('	')
		out_file.write (str(el[2]))
		out_file.write ('	')
		out_file.write (str(el[3]))
		out_file.write ('\n')
		
	out_file.close()
	
main()